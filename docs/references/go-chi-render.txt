================================================================================
go-chi/render v1.0.3 — Quick API Reference
================================================================================
Source: github.com/go-chi/render
Docs:   pkg.go.dev/github.com/go-chi/render
License: MIT

INTERFACES
---
type Binder interface {
    Bind(r *http.Request) error
}

type Renderer interface {
    Render(w http.ResponseWriter, r *http.Request) error
}

Binder is called AFTER decoding — use it to validate, sanitize, or reject.
Renderer is called BEFORE responding — use it to compute derived fields or set status.

Processing order:
  Bind:   bottom-up (nested Binder fields first, then parent Bind)
  Render: top-down  (parent Render first, then nested Renderer fields)
Both use reflection to discover nested struct fields implementing the interface.
Nil-valued fields are skipped.


CONVENIENCE TYPE
---
type M map[string]interface{}

Short-hand for ad-hoc JSON objects:
  render.JSON(w, r, render.M{"ok": true})


CONTENT TYPE ENUM
---
type ContentType int

const (
    ContentTypeUnknown ContentType = iota
    ContentTypePlainText            // text/plain
    ContentTypeHTML                 // text/html
    ContentTypeJSON                 // application/json
    ContentTypeXML                  // application/xml, text/xml
    ContentTypeForm                 // application/x-www-form-urlencoded
    ContentTypeEventStream          // text/event-stream
)


CONTEXT KEYS
---
render.StatusCtxKey       — stores HTTP status code hint in request context
render.ContentTypeCtxKey  — stores forced ContentType in request context


PACKAGE-LEVEL OVERRIDES
---
var Decode  = DefaultDecoder   // func(r *http.Request, v interface{}) error
var Respond = DefaultResponder // func(w http.ResponseWriter, r *http.Request, v interface{})

Replace these to customize global decode/respond behavior.


REQUEST BINDING
---
func Bind(r *http.Request, v Binder) error

  1. Calls Decode(r, v)  — decodes body based on Content-Type header
  2. Calls v.Bind(r)     — your validation/post-processing hook
  Returns first non-nil error from either step.

func DefaultDecoder(r *http.Request, v interface{}) error

  Routes to format-specific decoder based on GetRequestContentType(r):
    ContentTypeJSON -> DecodeJSON(r.Body, v)
    ContentTypeXML  -> DecodeXML(r.Body, v)
    ContentTypeForm -> DecodeForm(r.Body, v)
    default         -> error("unable to automatically decode")

func DecodeJSON(r io.Reader, v interface{}) error
func DecodeXML(r io.Reader, v interface{}) error
func DecodeForm(r io.Reader, v interface{}) error

  Low-level decoders. JSON/XML drain the reader after decoding.
  Form uses github.com/ajg/form.


RESPONSE RENDERING
---
func Render(w http.ResponseWriter, r *http.Request, v Renderer) error

  1. Calls v.Render(w, r) — your pre-response hook (set status, compute fields)
  2. Calls Respond(w, r, v) — marshals and writes

func RenderList(w http.ResponseWriter, r *http.Request, l []Renderer) error

  Calls Render processing on each element, then responds with the collected list.

func DefaultResponder(w http.ResponseWriter, r *http.Request, v interface{})

  Checks GetAcceptedContentType(r):
    ContentTypeJSON        -> JSON(w, r, v)
    ContentTypeXML         -> XML(w, r, v)
    ContentTypeEventStream -> channel streaming (SSE)
    default                -> JSON(w, r, v)

  Before writing, checks StatusCtxKey on request context for status code hint.


RESPOND HELPERS
---
func JSON(w http.ResponseWriter, r *http.Request, v interface{})
  Marshals v to JSON with HTML escaping. Sets Content-Type: application/json.
  Reads StatusCtxKey from context for status code (default 200).

func XML(w http.ResponseWriter, r *http.Request, v interface{})
  Marshals v to XML. Prepends <?xml ...?> header if not present in first 100 bytes.
  Sets Content-Type: application/xml.

func PlainText(w http.ResponseWriter, r *http.Request, v string)
  Writes string. Sets Content-Type: text/plain.

func HTML(w http.ResponseWriter, r *http.Request, v string)
  Writes string. Sets Content-Type: text/html.

func Data(w http.ResponseWriter, r *http.Request, v []byte)
  Writes raw bytes. Sets Content-Type: application/octet-stream.

func NoContent(w http.ResponseWriter, r *http.Request)
  Writes HTTP 204 No Content. No body.


STATUS SETTING
---
func Status(r *http.Request, status int)

  Stores status code hint in request context via StatusCtxKey.
  Must be called BEFORE Respond/JSON/XML writes the header.
  Typically called inside a Renderer.Render() method or before render.Render().

  render.Status(r, http.StatusCreated)
  render.Render(w, r, response)


CONTENT NEGOTIATION
---
func SetContentType(ct ContentType) func(next http.Handler) http.Handler
  Middleware — forces content type for all handlers downstream.
  Stores ct in context; both decoder and responder check context first.

func GetContentType(s string) ContentType
  Parses a MIME string ("application/json") into ContentType enum.

func GetRequestContentType(r *http.Request) ContentType
  Returns ContentType by checking: context value first, then Content-Type header.
  Used by DefaultDecoder to pick the right decoder.

func GetAcceptedContentType(r *http.Request) ContentType
  Returns ContentType by checking: context value first, then Accept header.
  Used by DefaultResponder to pick the right response format.
  Falls back to ContentTypePlainText for unrecognized Accept values.


PATTERN: IMPLEMENT Binder FOR REQUEST TYPES
---
type CreateArticleRequest struct {
    *Article
    ProtectedID string `json:"id"` // field to strip
}

func (req *CreateArticleRequest) Bind(r *http.Request) error {
    if req.Article == nil {
        return errors.New("missing required Article fields")
    }
    req.ProtectedID = ""                          // strip client-supplied ID
    req.Article.Title = strings.ToLower(req.Title) // normalize
    return nil
}

// In handler:
func CreateArticle(w http.ResponseWriter, r *http.Request) {
    req := &CreateArticleRequest{}
    if err := render.Bind(r, req); err != nil {
        render.Render(w, r, ErrInvalidRequest(err))
        return
    }
    // use req.Article ...
}


PATTERN: IMPLEMENT Renderer FOR RESPONSE TYPES
---
type ArticleResponse struct {
    *Article
    User    *UserPayload `json:"user,omitempty"`
    Elapsed int64        `json:"elapsed"`
}

func (resp *ArticleResponse) Render(w http.ResponseWriter, r *http.Request) error {
    resp.Elapsed = 10 // compute derived field
    return nil
}

func NewArticleResponse(a *Article) *ArticleResponse {
    return &ArticleResponse{Article: a}
}

// For lists — convert to []render.Renderer:
func NewArticleListResponse(articles []*Article) []render.Renderer {
    list := make([]render.Renderer, 0, len(articles))
    for _, a := range articles {
        list = append(list, NewArticleResponse(a))
    }
    return list
}


PATTERN: ERROR RESPONSES
---
type ErrResponse struct {
    Err            error `json:"-"`               // internal only
    HTTPStatusCode int   `json:"-"`               // set via render.Status
    StatusText     string `json:"status"`
    AppCode        int64  `json:"code,omitempty"`
    ErrorText      string `json:"error,omitempty"`
}

func (e *ErrResponse) Render(w http.ResponseWriter, r *http.Request) error {
    render.Status(r, e.HTTPStatusCode)
    return nil
}

// Reusable error constructors:
var ErrNotFound = &ErrResponse{HTTPStatusCode: 404, StatusText: "Resource not found."}

func ErrInvalidRequest(err error) render.Renderer {
    return &ErrResponse{
        Err:            err,
        HTTPStatusCode: 400,
        StatusText:     "Invalid request.",
        ErrorText:      err.Error(),
    }
}

func ErrRender(err error) render.Renderer {
    return &ErrResponse{
        Err:            err,
        HTTPStatusCode: 422,
        StatusText:     "Error rendering response.",
        ErrorText:      err.Error(),
    }
}

// Usage:
render.Render(w, r, ErrNotFound)
render.Render(w, r, ErrInvalidRequest(err))


PATTERN: HANDLER USING ALL PIECES
---
func CreateArticle(w http.ResponseWriter, r *http.Request) {
    data := &ArticleRequest{}
    if err := render.Bind(r, data); err != nil {
        render.Render(w, r, ErrInvalidRequest(err))
        return
    }
    article := data.Article
    dbNewArticle(article)

    render.Status(r, http.StatusCreated)
    render.Render(w, r, NewArticleResponse(article))
}

func ListArticles(w http.ResponseWriter, r *http.Request) {
    if err := render.RenderList(w, r, NewArticleListResponse(articles)); err != nil {
        render.Render(w, r, ErrRender(err))
        return
    }
}

func DeleteArticle(w http.ResponseWriter, r *http.Request) {
    // ... delete logic ...
    render.NoContent(w, r)
}

func GetRawData(w http.ResponseWriter, r *http.Request) {
    render.JSON(w, r, render.M{"status": "ok", "count": 42})
}


PATTERN: CONTENT TYPE MIDDLEWARE
---
r := chi.NewRouter()
r.Use(render.SetContentType(render.ContentTypeJSON))
// All handlers downstream will negotiate as JSON by default.
