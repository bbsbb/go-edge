// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: products.sql

package sqlcgen

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createProduct = `-- name: CreateProduct :exec
INSERT INTO app_sweetshop.products (id, organization_id, system_created_at, system_updated_at, name, category, price_cents)
VALUES ($1, $2, $3, $4, $5, $6, $7)
`

type CreateProductParams struct {
	ID              uuid.UUID
	OrganizationID  uuid.UUID
	SystemCreatedAt time.Time
	SystemUpdatedAt time.Time
	Name            string
	Category        string
	PriceCents      int32
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) error {
	_, err := q.db.Exec(ctx, createProduct,
		arg.ID,
		arg.OrganizationID,
		arg.SystemCreatedAt,
		arg.SystemUpdatedAt,
		arg.Name,
		arg.Category,
		arg.PriceCents,
	)
	return err
}

const deleteProduct = `-- name: DeleteProduct :execrows
DELETE FROM app_sweetshop.products WHERE id = $1
`

func (q *Queries) DeleteProduct(ctx context.Context, id uuid.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, deleteProduct, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const findProductByID = `-- name: FindProductByID :one
SELECT id, organization_id, system_created_at, system_updated_at, name, category, price_cents FROM app_sweetshop.products WHERE id = $1
`

func (q *Queries) FindProductByID(ctx context.Context, id uuid.UUID) (Product, error) {
	row := q.db.QueryRow(ctx, findProductByID, id)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.SystemCreatedAt,
		&i.SystemUpdatedAt,
		&i.Name,
		&i.Category,
		&i.PriceCents,
	)
	return i, err
}

const listProducts = `-- name: ListProducts :many
SELECT id, organization_id, system_created_at, system_updated_at, name, category, price_cents FROM app_sweetshop.products ORDER BY name
`

func (q *Queries) ListProducts(ctx context.Context) ([]Product, error) {
	rows, err := q.db.Query(ctx, listProducts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Product{}
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.SystemCreatedAt,
			&i.SystemUpdatedAt,
			&i.Name,
			&i.Category,
			&i.PriceCents,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProduct = `-- name: UpdateProduct :execrows
UPDATE app_sweetshop.products
SET system_updated_at = $2, name = $3, category = $4, price_cents = $5
WHERE id = $1
`

type UpdateProductParams struct {
	ID              uuid.UUID
	SystemUpdatedAt time.Time
	Name            string
	Category        string
	PriceCents      int32
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateProduct,
		arg.ID,
		arg.SystemUpdatedAt,
		arg.Name,
		arg.Category,
		arg.PriceCents,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
